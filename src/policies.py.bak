"""
Policy gate functions capture "governance regimes" without hard‑coding ideology.
- funding_gate: probability a prototype secures funds this step
- oversight_gate: probability it clears oversight/milestones this step

Regimes:
- linear  : centralized, rigid milestones, slower feedback loops
- adaptive: decentralized, rolling evaluations, accelerated funding agility
- shock   : temporary disruption to budgets/oversight to test resilience
"""
from __future__ import annotations

from typing import Literal

Regime = Literal["linear", "adaptive", "shock"]


def funding_gate(model, researcher) -> bool:
    """
    Funding availability proxy:
    - linear   : conservative baseline (queue + narrow color of money)
    - adaptive : more flexible (e.g., OTA‑like agility or reprogramming ease)
    - shock    : temporary compression of RDTE, partial recovery after window
    """
    if model.regime == "linear":
        p = 0.3 * model.funding_rdte
    elif model.regime == "adaptive":
        p = 0.5 * (model.funding_rdte + model.funding_om)
    else:  # shock
        if model.is_in_shock():
            p = 0.15 * model.funding_rdte
        else:
            p = 0.45 * (model.funding_rdte + 0.5 * model.funding_om)

    return model.random.random() < p


def oversight_gate(model, researcher) -> bool:
    """
    Oversight pass probability:
    Lower rigidity => easier to pass, but we still factor in prototype quality.
    """
    if model.regime == "linear":
        rigidity = 0.8  # high drag
    elif model.regime == "adaptive":
        rigidity = 0.3  # rolling evaluations
    else:  # shock
        rigidity = 0.6 if model.is_in_shock() else 0.4

    # Convert rigidity + quality to pass probability (0.05 floor to avoid stall)
    pass_prob = max(0.05, (1.0 - rigidity) * 0.7 + 0.3 * researcher.quality)
    return model.random.random() < pass_prob


# ------------------ Extended typing ------------------
from typing import Literal as _LiteralAlias  # alias to avoid mypy confusion in some setups
LegalStatus = _LiteralAlias("favorable", "favorable_with_caveats", "unfavorable", "not_conducted")


# ------------------ Stage-pipeline gates ------------------
def funding_gate_stage(model, researcher, stage: str) -> bool:
    """
    Stage-aware funding availability with coarse "color" behavior.
    - Early stages (feasibility, prototype_demo) rely mainly on RDT&E.
    - Later stages (functional/vulnerability/operational test) may leverage O&M/Proc-like pools.
    Funding source types (POM, UFR, ProgramBase, External, Partner, Partner_CoDev)
    modulate probability as simple multipliers.
    """
    stage = str(stage)
    early = stage in {"feasibility", "prototype_demo"}
    if model.regime == "linear":
        base = 0.25 if early else 0.2
    elif model.regime == "adaptive":
        base = 0.4 if early else 0.35
    else:  # shock
        if model.is_in_shock():
            base = 0.15 if early else 0.1
        else:
            base = 0.35 if early else 0.3

    # Color weights
    color_weight = model.funding_rdte if early else (0.5 * model.funding_rdte + 0.5 * model.funding_om)

    # Funding source multiplier
    source = getattr(researcher, "funding_source", "ProgramBase")
    source_mult = {
        "POM": 0.9,
        "ProgramBase": 1.0,
        "UFR": 0.7,
        "External": 0.8,
        "Partner": 0.75,
        "Partner_CoDev": 0.85,
    }.get(source, 1.0)

    p = max(0.02, min(0.98, base * color_weight * source_mult))
    return model.random.random() < p


def legal_review_gate(model, researcher) -> str:
    """
    Return a legal review outcome string.
    Factors: authority (Title10/Title50), domain, kinetic vs non-kinetic.
    """
    authority = getattr(researcher, "authority", "Title10")
    kinetic = getattr(researcher, "kinetic_category", "NonKinetic")

    # Baseline distribution
    dist = {
        "favorable": 0.6,
        "favorable_with_caveats": 0.25,
        "unfavorable": 0.1,
        "not_conducted": 0.05,
    }

    # Title 50 tends to shift to more caveats/unfavorable
    if authority == "Title50":
        dist["favorable"] = max(0.0, dist["favorable"] - 0.1)
        dist["favorable_with_caveats"] += 0.07
        dist["unfavorable"] += 0.03

    # Kinetic domains push toward more scrutiny
    if kinetic == "Kinetic":
        dist["favorable"] = max(0.0, dist["favorable"] - 0.05)
        dist["favorable_with_caveats"] += 0.03
        dist["unfavorable"] += 0.02

    # Normalize and sample
    total = sum(dist.values())
    r = model.random.random() * total
    acc = 0.0
    for k, v in dist.items():
        acc += v
        if r <= acc:
            return k
    return "favorable"  # fallback


def contracting_gate(model, researcher) -> bool:
    """Probability that contracting/vehicle path is successful this tick."""
    org = getattr(researcher, "org_type", "GovContractor")

    base = {
        "GovLab": 0.6,
        "GovContractor": 0.55,
        "Commercial": 0.5,
    }.get(org, 0.55)

    # Adaptive regimes ease flexible instruments (e.g., OTA-like paths)
    if model.regime == "adaptive" and org in {"Commercial", "GovContractor"}:
        base += 0.1
    if model.regime == "linear" and org == "Commercial":
        base -= 0.05

    if model.regime == "shock" and model.is_in_shock():
        base -= 0.1

    p = max(0.05, min(0.95, base))
    return model.random.random() < p


def test_gate(model, researcher, stage: str, legal_status: str) -> bool:
    """
    Stage-specific technical/test pass probability.
    Factors: stage difficulty, TRL, domain, kinetic, legal caveats, regime, shocks.
    """
    stage = str(stage)
    trl = getattr(researcher, "trl", 3)
    domain = getattr(researcher, "domain", "Generic")
    kinetic = getattr(researcher, "kinetic_category", "NonKinetic")

    # Base difficulty by stage (higher is easier)
    base = {
        "feasibility": 0.7,
        "prototype_demo": 0.65,
        "functional_test": 0.6,
        "vulnerability_test": 0.55,
        "operational_test": 0.5,
    }.get(stage, 0.6)

    # TRL contribution (TRL 1..9 mapped ~0..0.2)
    trl_bonus = min(0.2, max(0.0, (trl - 3) * 0.03))

    # Domain/Kinetic adjustments
    if kinetic == "Kinetic":
        base -= 0.05
    if domain in {"Cyber", "EW"} and stage in {"vulnerability_test", "operational_test"}:
        base -= 0.05

    # Legal caveats penalty; not_conducted slightly riskier
    if legal_status == "favorable_with_caveats":
        base -= 0.03
    elif legal_status == "not_conducted":
        base -= 0.02
    elif legal_status == "unfavorable":
        return False

    # Regime/shock effects
    if model.regime == "adaptive":
        base += 0.03
    if model.regime == "shock" and model.is_in_shock():
        base -= 0.05

    p = max(0.05, min(0.95, base + trl_bonus))
    return model.random.random() < p
